{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"MaxGradient <p>MaxGradient automates printing gradient colored text to the console. It's built upon the great rich library. It contains a Console that can serve as a drop in replacement for rich.console.Console and has an expanded Color class which can parse X11 color names on top of rich's standard colors. MaxGradient is a work in progress and I'm open to any suggestions or contributions.</p> Installation  MaxGradient can be installed from PyPi using your favorite python package manager:  PDM (Recommended) <pre><code>pdm add maxgradient\n</code></pre> PIP <pre><code>pip install maxgradient\n</code></pre> Usage Quick Start  The basic usage is to create a console object and use it to print gradient text. MaxGradient.Console is a drop in replacement for rich.rich.Console and can be used in the same way. It does, however, have some additional methods like  gradient().  Example <pre><code>#import console from MaxGradient\nimport maxgradient as mg\n\nconsole = mg.Console() # Initialize a console\nconsole.gradient(\n    \"Hello, World!\",\n    justify = \"center\"\n)\n</code></pre> Gradient with Color <p>MaxGradient easily make random gradients that require no more than the text you wish to color, it can also be used to make gradients with specific colors. The gradient() method takes a string of text as well as a list of colors. The number of colors in the list determines the number of colors in the gradient. The gradient will be evenly distributed between the colors in the list. The gradient will be applied to the text in the order it is given in the list.</p> <p>MaxGradient accepts the following as </p> <ul> <li>color names (red, orange, yellow, green, cyan, lightblue, blue, purple, violet, magenta)</li> <li>hex color codes (3-digit -&gt; #f0f, 6-digit -&gt; #ff00ff)</li> <li>rgb color codes</li> <li>X11 named colors</li> <li>as well as any colors from rich's standard library.</li> </ul> <p>Let's take a look at some examples:</p> Example 1 <pre><code>import maxgradient as mg\n\nconsole = mg.Console()\n\nconsole.gradient(\n    \"This gradient contains the colors: magenta, violet, and purple.\",\n    colors = [\n        \"magenta\",\n        \"violet\",\n        \"purple\"\n    ]\n)\n</code></pre> Example 2  You are not just stuck with ROY G BIV colors, you can use any colors you want. Let's make a gradient with the colors: magenta, violet, purple, blue, lightblue, and cyan.  <pre><code>console.gradient(\n    \"This gradient contains the colors: magenta, violet, purple, blue, lightblue, and cyan.\",\n    colors = [\n        \"rgb(255,0,255)\", # rgb | magenta\n        \"violet\", # named (#af00ff)\n        \"#5f00ff\", # hex | purple\n        \"blue\", # another named\n        \"rgb(0, 136, 255)\", # rgb | lightblue\n        \"cyan\" # and another\n    ]\n)\n</code></pre> Created by  Max Ludden"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v0217","title":"v0.2.17","text":"<p>January 6, 2024 | Changed layout to src</p>"},{"location":"CHANGELOG/#version-changes","title":"Version Changes","text":"<ul> <li>Changed layout to src</li> <li>Ran tests and fixed conflicts</li> <li>Added <code>__init__.py</code> to <code>maxgradient</code> directory</li> </ul>"},{"location":"CHANGELOG/#dependancy-updates","title":"Dependancy Updates","text":"<ul> <li>Updated <code>rich</code> to v10.6.0</li> <li>Updated <code>pydantic</code> to v1.9.0</li> <li>Updated <code>pytest</code> to v6.2.5</li> </ul>"},{"location":"CHANGELOG/#v0216","title":"v0.2.16","text":"<p>January 3, 2024 | Reverted to v0.2.14</p> <ul> <li>Reverted to v0.2.14</li> </ul>"},{"location":"CHANGELOG/#version-changes_1","title":"Version Changes","text":"<ul> <li>Added themes.py to mirror rich's themes.py</li> <li>Bug fixes for gradient.py and console.py</li> </ul>"},{"location":"CHANGELOG/#dependancy-updates_1","title":"Dependancy Updates","text":"<ul> <li>Removed snoop from modules</li> </ul>"},{"location":"CHANGELOG/#v0215","title":"v0.2.15","text":"<p>January 2, 2024 | Fixed Gradient and Updated Dependencies</p> <ul> <li>Fixed gradient so that it works with the latest version of <code>rich</code></li> <li>Updated dependancies to latest versions</li> </ul>"},{"location":"CHANGELOG/#v0214","title":"v0.2.14","text":"<p>December 18, 2023 | Updated dependancies</p> <ul> <li>Updated and locked dependancies to latest versions</li> <li>Added ruff configuration file</li> </ul>"},{"location":"CHANGELOG/#v0213","title":"v0.2.13","text":"<p>December 5, 2023 | Allowed arbitrary types for console</p> <ul> <li>I was allowed arbitrary pydantic types for the console class</li> </ul>"},{"location":"CHANGELOG/#v0212","title":"v0.2.12","text":"<p>December 1, 2023 | Added Tests</p> <ul> <li>Updated banner image for <code>README.md</code> and <code>docs/index.md</code></li> <li>Seperated Changelog into its own file: <code>docs/CHANGELOG.md</code></li> <li>Added <code>py.typed</code> file to project                    directory</li> </ul>"},{"location":"CHANGELOG/#v0211","title":"v0.2.11","text":"<p>November 28, 2023 | Added Tests</p> <ul> <li>Removed color_sample and invert from gradient attributes</li> <li>Added tests for console, color, and gradient</li> </ul>"},{"location":"CHANGELOG/#v0210","title":"v0.2.10","text":"<p>November 25, 2023 | Added Dates</p> <ul> <li>Updated changlog to have dates</li> <li>added logo and favicon to changelog</li> </ul>"},{"location":"CHANGELOG/#v029","title":"v0.2.9","text":"<p>November 25, 2023 | Updated Banner</p> <ul> <li>Updated MaxGradient Logo and Favicon</li> <li>Updated banner to include new logo as http rather than referencing the SVG file locally.</li> </ul>"},{"location":"CHANGELOG/#v028","title":"v0.2.8","text":"<p>November 25, 2023 | Fixed <code>cli.py</code></p> <ul> <li>Fixed <code>cli.py</code> so that it works with the new <code>gradient</code> method</li> <li>Removed logging</li> </ul>"},{"location":"CHANGELOG/#v027","title":"v0.2.7","text":"<p>November 25, 2023 | Bug Fixes</p> <ul> <li>Combined multiple CSS stylesheets into one:<ul> <li><code>next-btn.css</code> -&gt; <code>style.css</code></li> <li><code>gradient.css</code> -&gt; <code>style.css</code></li> </ul> </li> <li>General corrections to every file after correcting for Mypy</li> </ul>"},{"location":"CHANGELOG/#v026","title":"v0.2.6","text":"<p>November 18, 2023 | Type Stubs</p> <ul> <li>Added type stubs - Mypy should work now</li> <li>Simplified <code>maxgradient.log.py</code> and fixed line lengths</li> </ul>"},{"location":"CHANGELOG/#v024","title":"v0.2.4","text":"<ul> <li>Rewrote <code>MaxGradient.console.Console</code> to replicate <code>rich.console.Console</code><ul> <li>added <code>gradient</code> method</li> <li>added <code>gradient_rule</code> method</li> </ul> </li> <li>Switched to <code>ruff</code> for linting</li> <li>Pruned dependencies</li> <li>Updated default_styles.GRADIENT_STYLES</li> </ul>"},{"location":"CHANGELOG/#v023","title":"v0.2.3","text":"<ul> <li>Updated docs and added more examples and reference</li> <li>Fixed bugs<ul> <li>Fixed bug where gradient would not print if gradient was the only thing in the console</li> <li>Fixed bug where gradient wouldn't print if the style wasn't a <code>rich.style.Style</code> object</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#v022","title":"v0.2.2","text":"<ul> <li>Added examples to docs and fixed some typos and bugs</li> <li>Disabled logging</li> <li>Fixed gradient class</li> <li>Added gradient rules</li> </ul>"},{"location":"color/","title":"MaxGradient.Color","text":"<p>Color extends the Rich.color.Color class to allow colors to be parsed from:</p> <ul> <li>X11 color names (over 200 colors)</li> <li>Rich's Standard Color Library</li> <li>Hex codes (3-digit and 6-digit)</li> <li>RGB values (with or without the 'rgb' prefix)</li> </ul> <p>A color can be represented as a string in numerous ways. The easiest is the name of the color:</p> <ul> <li>red</li> <li>magenta</li> <li>blue</li> </ul> <p>You can also use the hex code of the color:</p> <ul> <li>#ff0000 (six digit hex code)</li> <li>#F0F (three digit hex code)</li> </ul> <p>Or the rgb values of the color:</p> <ul> <li>rgb(170,255,170) (with <code>rgb</code> prefix)</li> <li>(0, 255, 0) (<code>rgb</code> tuple without prefix)</li> </ul> <p>In addition to common names, MaxGradient also supports the entire rich color standard color palette. But we didn't stop there, in addition to rich's standard library, MaxGradient also supports the entire X11 color palette. That's over 200 colors!</p>"},{"location":"color/#example-1-colorred","title":"Example 1: Color(\"red\")","text":"<pre><code>from maxgradient import Color, Console\n\nconsole = Console()\nconsole.print(\n    Color(\"red\"),\n    justify=\"center\"\n)\n</code></pre>"},{"location":"color/#example-2-coloraaffaa","title":"Example 2:  Color(\"#AAFFAA\")","text":"<pre><code>console.print(\n    Color(\"#aaffaa\"),\n    justify = \"center\"\n)\n</code></pre>"},{"location":"color/#example-3-colordarkorchid","title":"Example 3: Color(\"DarkOrchid\")","text":"<pre><code>console.print(\n    Color(\"DarkOrchid\"),\n    justify = \"center\"\n)\n</code></pre>"},{"location":"color_ref/","title":"MaxGradient.color.Color Reference","text":"<p>A class to represent a color that inherits and expands <code>rich.rich.Color</code> to include X11 named colors as well as multiple formats of hex and rgb colors.</p>"},{"location":"color_ref/#initialize","title":"Initialize","text":"class Color (self, color: Any) -&gt; None:"},{"location":"color_ref/#parameters","title":"Parameters","text":"Name Type Description color Union[str, tuple, Color] The color to be represented.The color may be:<ul><li>the color name<ul><li>color names (red, orange, yellow, green, cyan, lightblue, blue, purple, violet, magenta)</li><li>hex color codes (3-digit -&gt; #f0f, 6-digit -&gt; #ff00ff)</li><li>rgb color codes</li><li>X11 named colors</li><li>as well as any colors from rich's standard library.</li></ul></li><li>the hex color code</li><li>the rgb color code</li><li>the rgb color tuple</li><li>a <code>maxgradient.color.Color</code> object</li>"},{"location":"color_ref/#attributes","title":"Attributes","text":"Name Type Description original str The original color passed to the constructor. red int The red value of the color. green int The green value of the color. blue int The blue value of the color. name str The name of the color. If the color is not a named color, this will default to the hex color code. hex str The hex color code of the color. rgb str The rgb color code of the color. triplet tuple The rgb color tuple of the color. style rich.style.Style A style object with the color as the foreground color. bg_style rich.style.Style A style object with the color as the background color."},{"location":"color_ref/#methods","title":"Methods","text":"<ul> <li>get_contrast(self) -&gt; str: <p> Generate the color of the foreground if the color is the background. Ie. lighter colors with return black, and darker colors will return white.</p> <ul> <li>lighten(self, percent: float = 0.5) -&gt; str:</li> </ul> <p> Generate a tint of the color. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - percent (float): The amount of white to add to the color. </p> <ul> <li>darken(self, percent: float = 0.5) -&gt; str:</li> </ul> <p> Generate a tint of the color. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0- percent (float): The amount of black to add to the color. </p>"},{"location":"console/","title":"Console","text":"<p>MaxGradient.console.Console() is a subclass of rich.console.Console() that adds gradient functionality to the console. Just it can be instantiated in multiple ways:</p> <p>Directly:</p> <pre><code>from maxgradient import Console\n\nconsole = Console()\nconsole.print(\"[bold lime]Hello, World![/]\")\n</code></pre> <p></p>"},{"location":"console/#new-methods","title":"New Methods","text":"<p>Console also has two new methods that you can take advantage of in your projects:</p>"},{"location":"console/#first-new-method","title":"First New Method","text":""},{"location":"console/#consolegradient","title":"Console.gradient()","text":"<p>There's and low level look at <code>MaxGradient.gradient.Gradient</code>'s class in the next section. For now, just know that any of the parameters that can be used by <code>MaxGradient.gradient.Gradient()</code> can also be used by <code>console.gradient()</code>.</p>"},{"location":"console/#example","title":"Example","text":"<pre><code>console.gradient(\n    \"This is by far the simplest way to print \\\n        gradient colored text to the console.\",\n    colors = [\n        \"red\",\n        \"orange\",\n        \"yellow\",\n        \"green\"\n    ],\n    justify = \"center\",\n    style = \"bold\"\n)\n</code></pre>"},{"location":"console/#second-new-method","title":"Second New Method","text":""},{"location":"console/#consolegradient_rule","title":"Console.gradient_rule()","text":"<p><code>Console.gradient_rule()</code> expands on <code>rich.rule.Rule()</code> by allowing you to specify both the colors of the rule's gradient, as well as the rule's thickness.</p>"},{"location":"console/#examples","title":"Examples","text":""},{"location":"console/#gradient-rule","title":"Gradient Rule","text":"<pre><code>from maxgradient.console import Console\n\nconsole = Console()\nconsole.gradient_rule(\"Medium Gradient Rule\")\n</code></pre>"},{"location":"console_ref/","title":"maxgradient.console.Console","text":"<p>A custom-themed high level interface for the Console class that inherits from MMoMmaxgradient.console.Console. This class is a singleton which removes the need to pass around a console object or use the <code>get_console</code> method.</p>"},{"location":"console_ref/#initialize","title":"Initialize","text":"class Console ( \u00a0\u00a0\u00a0\u00a0self , \u00a0\u00a0\u00a0\u00a0* , \u00a0\u00a0\u00a0\u00a0color_system: Optional[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Literal[\"auto\", \"standard\", \"256\", \"truecolor\", \"windows\"]\u00a0\u00a0\u00a0\u00a0] = \"auto\",  \u00a0\u00a0\u00a0\u00a0force_terminal: Optional[bool] = None,  \u00a0\u00a0\u00a0\u00a0force_jupyter: Optional[bool] = None,  \u00a0\u00a0\u00a0\u00a0force_interactive: Optional[bool] = None,  \u00a0\u00a0\u00a0\u00a0soft_wrap: bool = None,  \u00a0\u00a0\u00a0\u00a0theme: Optional[Theme] = GradientTheme(),  \u00a0\u00a0\u00a0\u00a0stderr: bool = False, \u00a0\u00a0\u00a0\u00a0file: Optional[IO[str]] = stdout,  \u00a0\u00a0\u00a0\u00a0quiet: bool = False, \u00a0\u00a0\u00a0\u00a0width: Optional[int] = None,  \u00a0\u00a0\u00a0\u00a0height: Optional[int] = None,  \u00a0\u00a0\u00a0\u00a0style: Optional[StyleType] = None,  \u00a0\u00a0\u00a0\u00a0no_color: Optional[bool] = None,  \u00a0\u00a0\u00a0\u00a0tab_size: int = 4, \u00a0\u00a0\u00a0\u00a0record: bool = False, \u00a0\u00a0\u00a0\u00a0markup: bool = True, \u00a0\u00a0\u00a0\u00a0emoji: bool = True, \u00a0\u00a0\u00a0\u00a0emoji_variant: Optional[EmojiVariant] = None,  \u00a0\u00a0\u00a0\u00a0highlight: bool = True, \u00a0\u00a0\u00a0\u00a0log_time: bool = True, \u00a0\u00a0\u00a0\u00a0log_path: bool = True, \u00a0\u00a0\u00a0\u00a0log_time_format: Union[str, FormatTimeCallable] = \"[%X]\",  \u00a0\u00a0\u00a0\u00a0highlighter: Optional[HighlighterType] = ColorReprHightlighter(),  \u00a0\u00a0\u00a0\u00a0legacy_windows: Optional[bool] = None,  \u00a0\u00a0\u00a0\u00a0safe_box: bool = True, \u00a0\u00a0\u00a0\u00a0get_datetime: Optional[Callable[[], datetime]] = None,  \u00a0\u00a0\u00a0\u00a0get_time: Optional[Callable[[], float]] = None,  \u00a0\u00a0\u00a0\u00a0traceback: bool = True, \u00a0\u00a0\u00a0\u00a0traceback: bool = True, \u00a0\u00a0\u00a0\u00a0_environ: Optional[Mapping[str, str]] = None) -&gt; None:  <p>A high level console interface.</p> Parameters <ul> <li><p>color_system (str, optional) \u2013 The color system supported by your terminal, either <code>\"standard\"</code>, <code>\"256\"</code> or <code>\"truecolor\"</code>. Leave as <code>\"auto\"</code> to autodetect.</p></li> <li><p>force_terminal (Optional[bool], optional) \u2013 Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.</p></li> <li><p>force_jupyter (Optional[bool], optional) \u2013 Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.</p></li> <li><p>force_interactive (Optional[bool], optional) \u2013 Enable/disable interactive mode, or None to auto detect. Defaults to None.</p></li> <li><p>soft_wrap (Optional[bool], optional) \u2013 Set soft wrap default on print method. Defaults to False.</p></li> <li><p>theme (Theme, optional) \u2013 An optional style theme object, or <code>None</code> for default theme.</p></li> <li><p>stderr (bool, optional) \u2013 Use stderr rather than stdout if <code>file</code> is not specified. Defaults to False.</p></li> <li><p>file (IO, optional) \u2013 A file object where the console should write to. Defaults to stdout.</p></li> <li><p>quiet (bool, Optional) \u2013 Boolean to suppress all output. Defaults to False.</p></li> <li><p>width (int, optional) \u2013 The width of the terminal. Leave as default to auto-detect width.</p></li> <li><p>height (int, optional) \u2013 The height of the terminal. Leave as default to auto-detect height.</p></li> <li><p>style (StyleType, optional) \u2013 Style to apply to all output, or None for no style. Defaults to None.</p></li> <li><p>no_color (Optional[bool], optional) \u2013 Enabled no color mode, or None to auto detect. Defaults to None.</p></li> <li><p>tab_size (int, optional) \u2013 Number of spaces used to replace a tab character. Defaults to 8.</p></li> <li><p>record (bool, optional) \u2013 Boolean to enable recording of terminal output, required to call <code>export_html()</code>, <code>export_svg()</code>, and <code>export_text()</code>. Defaults to False.</p></li> <li><p>markup (bool, optional) \u2013 Boolean to enable Console Markup. Defaults to True.</p></li> <li><p>emoji (bool, optional) \u2013 Enable emoji code. Defaults to True.</p></li> <li><p>emoji_variant (str, optional) \u2013 Optional emoji variant, either \u201ctext\u201d or \u201cemoji\u201d. Defaults to None.</p></li> <li><p>highlight (bool, optional) \u2013 Enable automatic highlighting. Defaults to True.</p></li> <li><p>log_time (bool, optional) \u2013 Boolean to enable logging of time by <code>log()</code> methods. Defaults to True.</p></li> <li><p>log_path (bool, optional) \u2013 Boolean to enable the logging of the caller by <code>log()</code>. Defaults to True.</p></li> <li><p>log_time_format (Union[str, TimeFormatterCallable], optional) \u2013 If <code>log_time</code> is enabled, either string for strftime or callable that formats the time. Defaults to \u201c[%X] \u201c.</p></li> <li><p>highlighter (HighlighterType, optional) \u2013 Default highlighter.</p></li> <li><p>legacy_windows (bool, optional) \u2013 Enable legacy Windows mode, or <code>None</code> to auto detect. Defaults to <code>None</code>.</p></li> <li><p>safe_box (bool, optional) \u2013 Restrict box options that don\u2019t render on legacy Windows.</p></li> <li><p>get_datetime (Callable[[], datetime], optional) \u2013 Callable that gets the current time as a datetime.datetime object (used by Console.log), or None for datetime.now.</p></li> <li><p>get_time (Callable[[], time], optional) \u2013 Callable that gets the current time in seconds, default uses time.monotonic.</p></li> <li><p>_environ (Mapping[str, str]) \u2013 </p></li> </ul> begin_capture()[source]\u00b6 <p>Begin capturing console output. Call <code>end_capture()</code> to exit capture mode and return output.</p> Return type <p>None</p> bell()[source]\u00b6 <p>Play a \u2018bell\u2019 sound (if supported by the terminal).</p> Return type <p>None</p> capture()[source]\u00b6 <p>A context manager to capture the result of print() or log() in a string, rather than writing it to the console.</p> <p>Example</p> <pre>&gt;&gt;&gt; from rich.console import Console\n&gt;&gt;&gt; console = Console()\n&gt;&gt;&gt; with console.capture() as capture:\n...     console.print(\"[bold magenta]Hello World[/]\")\n&gt;&gt;&gt; print(capture.get())\n</pre> Copy to clipboard Returns <p>Context manager with disables writing to the terminal.</p> Return type <p>Capture</p> clear(home=True)[source]\u00b6 <p>Clear the screen.</p> Parameters <p>home (bool, optional) \u2013 Also move the cursor to \u2018home\u2019 position. Defaults to True.</p> Return type <p>None</p> clear_live()[source]\u00b6 <p>Clear the Live instance.</p> Return type <p>None</p> property color_system: Optional[str]\u00b6 <p>Get color system string.</p> Returns <p>\u201cstandard\u201d, \u201c256\u201d or \u201ctruecolor\u201d.</p> Return type <p>Optional[str]</p> control(*control)[source]\u00b6 <p>Insert non-printing control codes.</p> Parameters <ul> <li><p>control_codes (str) \u2013 Control codes, such as those that may move the cursor.</p></li> <li><p>control (Control) \u2013 </p></li> </ul> Return type <p>None</p> property encoding: str\u00b6 <p>Get the encoding of the console file, e.g. <code>\"utf-8\"</code>.</p> Returns <p>A standard encoding string.</p> Return type <p>str</p> end_capture()[source]\u00b6 <p>End capture mode and return captured string.</p> Returns <p>Console output.</p> Return type <p>str</p> export_html(*, theme=None, clear=True, code_format=None, inline_styles=False)[source]\u00b6 <p>Generate HTML from console contents (requires record=True argument in constructor).</p> Parameters <ul> <li><p>theme (TerminalTheme, optional) \u2013 TerminalTheme object containing console colors.</p></li> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code>.</p></li> <li><p>code_format (str, optional) \u2013 Format string to render HTML. In addition to \u2018{foreground}\u2019, \u2018{background}\u2019, and \u2018{code}\u2019, should contain \u2018{stylesheet}\u2019 if inline_styles is <code>False</code>.</p></li> <li><p>inline_styles (bool, optional) \u2013 If <code>True</code> styles will be inlined in to spans, which makes files larger but easier to cut and paste markup. If <code>False</code>, styles will be embedded in a style tag. Defaults to False.</p></li> </ul> Returns <p>String containing console contents as HTML.</p> Return type <p>str</p> export_svg(*, title='MaxGradient', theme=None, clear=True, code_format=svg, font_aspect_ratio=0.61,unique_id=None)[source]\u00b6 <p>Generate an SVG from the console contents (requires record=True in Console constructor).</p> Parameters <ul> <li><p>title (str, optional) \u2013 The title of the tab in the output image</p></li> <li><p>theme (TerminalTheme, optional) \u2013 The <code>TerminalTheme</code> object to use to style the terminal</p></li> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code></p></li> <li><p>code_format (str, optional) \u2013 Format string used to generate the SVG. Rich will inject a number of variables into the string in order to form the final SVG output. The default template used and the variables injected by Rich can be found by inspecting the <code>console.CONSOLE_SVG_FORMAT</code> variable.</p></li> <li><p>font_aspect_ratio (float, optional) \u2013 The width to height ratio of the font used in the <code>code_format</code> string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font). If you aren\u2019t specifying a different font inside <code>code_format</code>, you probably don\u2019t need this.</p></li> <li><p>unique_id (str, optional) \u2013 unique id that is used as the prefix for various elements (CSS styles, node ids). If not set, this defaults to a computed value based on the recorded content.</p></li> </ul> Return type <p>str</p> export_text(*, clear=True, styles=False)[source]\u00b6 <p>Generate text from console contents (requires record=True argument in constructor).</p> Parameters <ul> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code>.</p></li> <li><p>styles (bool, optional) \u2013 If <code>True</code>, ansi escape codes will be included. <code>False</code> for plain text. Defaults to <code>False</code>.</p></li> </ul> Returns <p>String containing console contents.</p> Return type <p>str</p> property file: IO[str]\u00b6 <p>Get the file object to write to.</p> get_style(name, *, default=None)[source]\u00b6 <p>Get a Style instance by its theme name or parse a definition.</p> Parameters <ul> <li><p>name (str) \u2013 The name of a style or a style definition.</p></li> <li><p>default (Optional[Union[str, Style]]) \u2013 </p></li> </ul> Returns <p>A Style object.</p> Return type <p>Style</p> Raises <p>MissingStyle \u2013 If no style could be parsed from name.</p> property height: int\u00b6 <p>Get the height of the console.</p> Returns <p>The height (in lines) of the console.</p> Return type <p>int</p> input(prompt='', *, markup=True, emoji=True, password=False, stream=None)[source]\u00b6 <p>Displays a prompt and waits for input from the user. The prompt may contain color / style.</p> <p>It works in the same way as Python\u2019s builtin <code>input()</code> function and provides elaborate line editing and history features if Python\u2019s builtin <code>readline</code> module is previously loaded.</p> Parameters <ul> <li><p>prompt (Union[str, Text]) \u2013 Text to render in the prompt.</p></li> <li><p>markup (bool, optional) \u2013 Enable console markup (requires a str prompt). Defaults to True.</p></li> <li><p>emoji (bool, optional) \u2013 Enable emoji (requires a str prompt). Defaults to True.</p></li> <li><p>password (bool) \u2013 (bool, optional): Hide typed text. Defaults to False.</p></li> <li><p>stream (Optional[TextIO]) \u2013 (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.</p></li> </ul> Returns <p>Text read from stdin.</p> Return type <p>str</p> property is_alt_screen: bool\u00b6 <p>Check if the alt screen was enabled.</p> Returns <p>True if the alt screen was enabled, otherwise False.</p> Return type <p>bool</p> property is_dumb_terminal: bool\u00b6 <p>Detect dumb terminal.</p> Returns <p>True if writing to a dumb terminal, otherwise False.</p> Return type <p>bool</p> property is_terminal: bool\u00b6 <p>Check if the console is writing to a terminal.</p> Returns <p>True if the console writing to a device capable of understanding terminal codes, otherwise False.</p> Return type <p>bool</p> line(count=1)[source]\u00b6 <p>Write new line(s).</p> Parameters <p>count (int, optional) \u2013 Number of new lines. Defaults to 1.</p> Return type <p>None</p> log(*objects, sep=' ', end='\\n', style=None, justify=None, emoji=None, markup=None, highlight=None, log_locals=False, _stack_offset=1)[source]\u00b6 <p>Log rich content to the terminal.</p> Parameters <ul> <li><p>objects (positional args) \u2013 Objects to log to the terminal.</p></li> <li><p>sep (str, optional) \u2013 String to write between print data. Defaults to \u201d \u201c.</p></li> <li><p>end (str, optional) \u2013 String to write at end of print data. Defaults to \u201c\\n\u201d.</p></li> <li><p>style (Union[str, Style], optional) \u2013 A style to apply to output. Defaults to None.</p></li> <li><p>justify (str, optional) \u2013 One of \u201cleft\u201d, \u201cright\u201d, \u201ccenter\u201d, or \u201cfull\u201d. Defaults to <code>None</code>.</p></li> <li><p>emoji (Optional[bool], optional) \u2013 Enable emoji code, or <code>None</code> to use console default. Defaults to None.</p></li> <li><p>markup (Optional[bool], optional) \u2013 Enable markup, or <code>None</code> to use console default. Defaults to None.</p></li> <li><p>highlight (Optional[bool], optional) \u2013 Enable automatic highlighting, or <code>None</code> to use console default. Defaults to None.</p></li> <li><p>log_locals (bool, optional) \u2013 Boolean to enable logging of locals where <code>log()</code> was called. Defaults to False.</p></li> <li><p>_stack_offset (int, optional) \u2013 Offset of caller from end of call stack. Defaults to 1.</p></li> </ul> Return type <p>None</p> measure(renderable, *, options=None)[source]\u00b6 <p>Measure a renderable. Returns a <code>Measurement</code> object which contains information regarding the number of characters required to print the renderable.</p> Parameters <ul> <li><p>renderable (RenderableType) \u2013 Any renderable or string.</p></li> <li><p>options (Optional[ConsoleOptions], optional) \u2013 Options to use when measuring, or None to use default options. Defaults to None.</p></li> </ul> Returns <p>A measurement of the renderable.</p> Return type <p>Measurement</p> property options: ConsoleOptions\u00b6 <p>Get default console options.</p> out(*objects, sep=' ', end='\\n', style=None, highlight=None)[source]\u00b6 <p>Output to the terminal. This is a low-level way of writing to the terminal which unlike <code>print()</code> won\u2019t pretty print, wrap text, or apply markup, but will optionally apply highlighting and a basic style.</p> Parameters <ul> <li><p>sep (str, optional) \u2013 String to write between print data. Defaults to \u201d \u201c.</p></li> <li><p>end (str, optional) \u2013 String to write at end of print data. Defaults to \u201c\\n\u201d.</p></li> <li><p>style (Union[str, Style], optional) \u2013 A style to apply to output. Defaults to None.</p></li> <li><p>highlight (Optional[bool], optional) \u2013 Enable automatic highlighting, or <code>None</code> to use console default. Defaults to <code>None</code>.</p></li> <li><p>objects (Any) \u2013 </p></li> </ul> Return type <p>None</p> pager(pager=None, styles=False, links=False)[source]\u00b6 <p>A context manager to display anything printed within a \u201cpager\u201d. The pager application is defined by the system and will typically support at least pressing a key to scroll.</p> Parameters <ul> <li><p>pager (Pager, optional) \u2013 A pager object, or None to use <code>SystemPager</code>. Defaults to None.</p></li> <li><p>styles (bool, optional) \u2013 Show styles in pager. Defaults to False.</p></li> <li><p>links (bool, optional) \u2013 Show links in pager. Defaults to False.</p></li> </ul> Return type <p>PagerContext</p> <p>Example</p> <pre>&gt;&gt;&gt; from rich.console import Console\n&gt;&gt;&gt; from rich.__main__ import make_test_card\n&gt;&gt;&gt; console = Console()\n&gt;&gt;&gt; with console.pager():\n        console.print(make_test_card())\n</pre> Copy to clipboard Returns <p>A context manager.</p> Return type <p>PagerContext</p> Parameters <ul> <li><p>pager (Optional[Pager]) \u2013 </p></li> <li><p>styles (bool) \u2013 </p></li> <li><p>links (bool) \u2013 </p></li> </ul> pop_render_hook()[source]\u00b6 <p>Pop the last renderhook from the stack.</p> Return type <p>None</p> pop_theme()[source]\u00b6 <p>Remove theme from top of stack, restoring previous theme.</p> Return type <p>None</p> print(*objects, sep=' ', end='\\n', style=None, justify=None, overflow=None, no_wrap=None, emoji=None, markup=None, highlight=None, width=None, height=None, crop=True, soft_wrap=None, new_line_start=False)[source]\u00b6 <p>Print to the console.</p> Parameters <ul> <li><p>objects (positional args) \u2013 Objects to log to the terminal.</p></li> <li><p>sep (str, optional) \u2013 String to write between print data. Defaults to \u201d \u201c.</p></li> <li><p>end (str, optional) \u2013 String to write at end of print data. Defaults to \u201c\\n\u201d.</p></li> <li><p>style (Union[str, Style], optional) \u2013 A style to apply to output. Defaults to None.</p></li> <li><p>justify (str, optional) \u2013 Justify method: \u201cdefault\u201d, \u201cleft\u201d, \u201cright\u201d, \u201ccenter\u201d, or \u201cfull\u201d. Defaults to <code>None</code>.</p></li> <li><p>overflow (str, optional) \u2013 Overflow method: \u201cignore\u201d, \u201ccrop\u201d, \u201cfold\u201d, or \u201cellipsis\u201d. Defaults to None.</p></li> <li><p>no_wrap (Optional[bool], optional) \u2013 Disable word wrapping. Defaults to None.</p></li> <li><p>emoji (Optional[bool], optional) \u2013 Enable emoji code, or <code>None</code> to use console default. Defaults to <code>None</code>.</p></li> <li><p>markup (Optional[bool], optional) \u2013 Enable markup, or <code>None</code> to use console default. Defaults to <code>None</code>.</p></li> <li><p>highlight (Optional[bool], optional) \u2013 Enable automatic highlighting, or <code>None</code> to use console default. Defaults to <code>None</code>.</p></li> <li><p>width (Optional[int], optional) \u2013 Width of output, or <code>None</code> to auto-detect. Defaults to <code>None</code>.</p></li> <li><p>crop (Optional[bool], optional) \u2013 Crop output to width of terminal. Defaults to True.</p></li> <li><p>soft_wrap (bool, optional) \u2013 Enable soft wrap mode which disables word wrapping and cropping of text or <code>None</code> for Console default. Defaults to <code>None</code>.</p></li> <li><p>new_line_start (bool, False) \u2013 Insert a new line at the start if the output contains more than one line. Defaults to <code>False</code>.</p></li> <li><p>height (Optional[int]) \u2013 </p></li> </ul> Return type <p>None</p> print_exception(*, width=100, extra_lines=3, theme=None, word_wrap=False, show_locals=False, suppress=(), max_frames=100)[source]\u00b6 <p>Prints a rich render of the last exception and traceback.</p> Parameters <ul> <li><p>width (Optional[int], optional) \u2013 Number of characters used to render code. Defaults to 100.</p></li> <li><p>extra_lines (int, optional) \u2013 Additional lines of code to render. Defaults to 3.</p></li> <li><p>theme (str, optional) \u2013 Override pygments theme used in traceback</p></li> <li><p>word_wrap (bool, optional) \u2013 Enable word wrapping of long lines. Defaults to False.</p></li> <li><p>show_locals (bool, optional) \u2013 Enable display of local variables. Defaults to False.</p></li> <li><p>suppress (Iterable[Union[str, ModuleType]]) \u2013 Optional sequence of modules or paths to exclude from traceback.</p></li> <li><p>max_frames (int) \u2013 Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.</p></li> </ul> Return type <p>None</p> print_json(json=None, *, data=None, indent=2, highlight=True, skip_keys=False, ensure_ascii=False, check_circular=True, allow_nan=True, default=None, sort_keys=False)[source]\u00b6 <p>Pretty prints JSON. Output will be valid JSON.</p> Parameters <ul> <li><p>json (Optional[str]) \u2013 A string containing JSON.</p></li> <li><p>data (Any) \u2013 If json is not supplied, then encode this data.</p></li> <li><p>indent (Union[None, int, str], optional) \u2013 Number of spaces to indent. Defaults to 2.</p></li> <li><p>highlight (bool, optional) \u2013 Enable highlighting of output: Defaults to True.</p></li> <li><p>skip_keys (bool, optional) \u2013 Skip keys not of a basic type. Defaults to False.</p></li> <li><p>ensure_ascii (bool, optional) \u2013 Escape all non-ascii characters. Defaults to False.</p></li> <li><p>check_circular (bool, optional) \u2013 Check for circular references. Defaults to True.</p></li> <li><p>allow_nan (bool, optional) \u2013 Allow NaN and Infinity values. Defaults to True.</p></li> <li><p>default (Callable, optional) \u2013 A callable that converts values that can not be encoded in to something that can be JSON encoded. Defaults to None.</p></li> <li><p>sort_keys (bool, optional) \u2013 Sort dictionary keys. Defaults to False.</p></li> </ul> Return type <p>None</p> push_render_hook(hook)[source]\u00b6 <p>Add a new render hook to the stack.</p> Parameters <p>hook (RenderHook) \u2013 Render hook instance.</p> Return type <p>None</p> push_theme(theme, *, inherit=True)[source]\u00b6 <p>Push a new theme on to the top of the stack, replacing the styles from the previous theme. Generally speaking, you should call <code>use_theme()</code> to get a context manager, rather than calling this method directly.</p> Parameters <ul> <li><p>theme (Theme) \u2013 A theme instance.</p></li> <li><p>inherit (bool, optional) \u2013 Inherit existing styles. Defaults to True.</p></li> </ul> Return type <p>None</p> render(renderable, options=None)[source]\u00b6 <p>Render an object in to an iterable of Segment instances.</p> <p>This method contains the logic for rendering objects with the console protocol. You are unlikely to need to use it directly, unless you are extending the library.</p> Parameters <ul> <li><p>renderable (RenderableType) \u2013 An object supporting the console protocol, or an object that may be converted to a string.</p></li> <li><p>options (ConsoleOptions, optional) \u2013 An options object, or None to use self.options. Defaults to None.</p></li> </ul> Returns <p>An iterable of segments that may be rendered.</p> Return type <p>Iterable[Segment]</p> render_lines(renderable, options=None, *, style=None, pad=True, new_lines=False)[source]\u00b6 <p>Render objects in to a list of lines.</p> <p>The output of render_lines is useful when further formatting of rendered console text is required, such as the Panel class which draws a border around any renderable object.</p> Args:<p>renderable (RenderableType): Any object renderable in the console. options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to <code>None</code>. style (Style, optional): Optional style to apply to renderables. Defaults to <code>None</code>. pad (bool, optional): Pad lines shorter than render width. Defaults to <code>True</code>. new_lines (bool, optional): Include \u201c</p> <p>\u201d characters at end of lines.</p> Returns:<p>List[List[Segment]]: A list of lines, where a line is a list of Segment objects.</p> Parameters <ul> <li><p>renderable (Union[ConsoleRenderable, RichCast, str]) \u2013 </p></li> <li><p>options (Optional[ConsoleOptions]) \u2013 </p></li> <li><p>style (Optional[Style]) \u2013 </p></li> <li><p>pad (bool) \u2013 </p></li> <li><p>new_lines (bool) \u2013 </p></li> </ul> Return type <p>List[List[Segment]]</p> render_str(text, *, style='', justify=None, overflow=None, emoji=None, markup=None, highlight=None, highlighter=None)[source]\u00b6 <p>Convert a string to a Text instance. This is called automatically if you print or log a string.</p> Parameters <ul> <li><p>text (str) \u2013 Text to render.</p></li> <li><p>style (Union[str, Style], optional) \u2013 Style to apply to rendered text.</p></li> <li><p>justify (str, optional) \u2013 Justify method: \u201cdefault\u201d, \u201cleft\u201d, \u201ccenter\u201d, \u201cfull\u201d, or \u201cright\u201d. Defaults to <code>None</code>.</p></li> <li><p>overflow (str, optional) \u2013 Overflow method: \u201ccrop\u201d, \u201cfold\u201d, or \u201cellipsis\u201d. Defaults to <code>None</code>.</p></li> <li><p>emoji (Optional[bool], optional) \u2013 Enable emoji, or <code>None</code> to use Console default.</p></li> <li><p>markup (Optional[bool], optional) \u2013 Enable markup, or <code>None</code> to use Console default.</p></li> <li><p>highlight (Optional[bool], optional) \u2013 Enable highlighting, or <code>None</code> to use Console default.</p></li> <li><p>highlighter (HighlighterType, optional) \u2013 Optional highlighter to apply.</p></li> </ul> Returns <p>Renderable object.</p> Return type <p>ConsoleRenderable</p> rule(title='', *, characters='\u2500', style='rule.line', align='center')[source]\u00b6 <p>Draw a line with optional centered title.</p> Parameters <ul> <li><p>title (str, optional) \u2013 Text to render over the rule. Defaults to \u201c\u201d.</p></li> <li><p>characters (str, optional) \u2013 Character(s) to form the line. Defaults to \u201c\u2500\u201d.</p></li> <li><p>style (str, optional) \u2013 Style of line. Defaults to \u201crule.line\u201d.</p></li> <li><p>align (str, optional) \u2013 How to align the title, one of \u201cleft\u201d, \u201ccenter\u201d, or \u201cright\u201d. Defaults to \u201ccenter\u201d.</p></li> </ul> Return type <p>None</p> save_html(path, *, theme=None, clear=True, code_format=inline_styles=False)[source]\u00b6 <p>Generate HTML from console contents and write to a file (requires record=True argument in constructor).</p> Parameters <ul> <li><p>path (str) \u2013 Path to write html file.</p></li> <li><p>theme (TerminalTheme, optional) \u2013 TerminalTheme object containing console colors.</p></li> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code>.</p></li> <li><p>code_format (str, optional) \u2013 Format string to render HTML. In addition to \u2018{foreground}\u2019, \u2018{background}\u2019, and \u2018{code}\u2019, should contain \u2018{stylesheet}\u2019 if inline_styles is <code>False</code>.</p></li> <li><p>inline_styles (bool, optional) \u2013 If <code>True</code> styles will be inlined in to spans, which makes files larger but easier to cut and paste markup. If <code>False</code>, styles will be embedded in a style tag. Defaults to False.</p></li> </ul> Return type <p>None</p> save_svg(path, *, title='Rich', theme=None, clear=True, code_format=svg, font_aspect_ratio=0.61, unique_id=None)[source]\u00b6 <p>Generate an SVG file from the console contents (requires record=True in Console constructor).</p> Parameters <ul> <li><p>path (str) \u2013 The path to write the SVG to.</p></li> <li><p>title (str, optional) \u2013 The title of the tab in the output image</p></li> <li><p>theme (TerminalTheme, optional) \u2013 The <code>TerminalTheme</code> object to use to style the terminal</p></li> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code></p></li> <li><p>code_format (str, optional) \u2013 Format string used to generate the SVG. Rich will inject a number of variables into the string in order to form the final SVG output. The default template used and the variables injected by Rich can be found by inspecting the <code>console.CONSOLE_SVG_FORMAT</code> variable.</p></li> <li><p>font_aspect_ratio (float, optional) \u2013 The width to height ratio of the font used in the <code>code_format</code> string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font). If you aren\u2019t specifying a different font inside <code>code_format</code>, you probably don\u2019t need this.</p></li> <li><p>unique_id (str, optional) \u2013 unique id that is used as the prefix for various elements (CSS styles, node ids). If not set, this defaults to a computed value based on the recorded content.</p></li> </ul> Return type <p>None</p> save_text(path, *, clear=True, styles=False)[source]\u00b6 <p>Generate text from console and save to a given location (requires record=True argument in constructor).</p> Parameters <ul> <li><p>path (str) \u2013 Path to write text files.</p></li> <li><p>clear (bool, optional) \u2013 Clear record buffer after exporting. Defaults to <code>True</code>.</p></li> <li><p>styles (bool, optional) \u2013 If <code>True</code>, ansi style codes will be included. <code>False</code> for plain text. Defaults to <code>False</code>.</p></li> </ul> Return type <p>None</p> screen(hide_cursor=True, style=None)[source]\u00b6 <p>Context manager to enable and disable \u2018alternative screen\u2019 mode.</p> Parameters <ul> <li><p>hide_cursor (bool, optional) \u2013 Also hide the cursor. Defaults to False.</p></li> <li><p>style (Style, optional) \u2013 Optional style for screen. Defaults to None.</p></li> </ul> Returns <p>Context which enables alternate screen on enter, and disables it on exit.</p> Return type <p>~ScreenContext</p> set_alt_screen(enable=True)[source]\u00b6 <p>Enables alternative screen mode.</p> <p>Note, if you enable this mode, you should ensure that is disabled before the application exits. See <code>screen()</code> for a context manager that handles this for you.</p> Parameters <p>enable (bool, optional) \u2013 Enable (True) or disable (False) alternate screen. Defaults to True.</p> Returns <p>True if the control codes were written.</p> Return type <p>bool</p> set_live(live)[source]\u00b6 <p>Set Live instance. Used by Live context manager.</p> Parameters <p>live (Live) \u2013 Live instance using this Console.</p> Raises <p>errors.LiveError \u2013 If this Console has a Live context currently active.</p> Return type <p>None</p> set_window_title(title)[source]\u00b6 <p>Set the title of the console terminal window.</p> <p>Warning: There is no means within Rich of \u201cresetting\u201d the window title to its previous value, meaning the title you set will persist even after your application exits.</p> <p><code>fish</code> shell resets the window title before and after each command by default, negating this issue. Windows Terminal and command prompt will also reset the title for you. Most other shells and terminals, however, do not do this.</p> <p>Some terminals may require configuration changes before you can set the title. Some terminals may not support setting the title at all.</p> <p>Other software (including the terminal itself, the shell, custom prompts, plugins, etc.) may also set the terminal window title. This could result in whatever value you write using this method being overwritten.</p> Parameters <p>title (str) \u2013 The new title of the terminal window.</p> Returns <p></p> True if the control code to change the terminal title was<p>written, otherwise False. Note that a return value of True does not guarantee that the window title has actually changed, since the feature may be unsupported/disabled in some terminals.</p> <p></p> Return type <p>bool</p> show_cursor(show=True)[source]\u00b6 <p>Show or hide the cursor.</p> Parameters <p>show (bool, optional) \u2013 Set visibility of the cursor.</p> Return type <p>bool</p> property size: ConsoleDimensions\u00b6 <p>Get the size of the console.</p> Returns <p>A named tuple containing the dimensions.</p> Return type <p>ConsoleDimensions</p> status(status, *, spinner='dots', spinner_style='status.spinner', speed=1.0, refresh_per_second=12.5)[source]\u00b6 <p>Display a status and spinner.</p> Parameters <ul> <li><p>status (RenderableType) \u2013 A status renderable (str or Text typically).</p></li> <li><p>spinner (str, optional) \u2013 Name of spinner animation (see python -m rich.spinner). Defaults to \u201cdots\u201d.</p></li> <li><p>spinner_style (StyleType, optional) \u2013 Style of spinner. Defaults to \u201cstatus.spinner\u201d.</p></li> <li><p>speed (float, optional) \u2013 Speed factor for spinner animation. Defaults to 1.0.</p></li> <li><p>refresh_per_second (float, optional) \u2013 Number of refreshes per second. Defaults to 12.5.</p></li> </ul> Returns <p>A Status object that may be used as a context manager.</p> Return type <p>Status</p> update_screen(renderable, *, region=None, options=None)[source]\u00b6 <p>Update the screen at a given offset.</p> Parameters <ul> <li><p>renderable (RenderableType) \u2013 A Rich renderable.</p></li> <li><p>region (Region, optional) \u2013 Region of screen to update, or None for entire screen. Defaults to None.</p></li> <li><p>x (int, optional) \u2013 x offset. Defaults to 0.</p></li> <li><p>y (int, optional) \u2013 y offset. Defaults to 0.</p></li> <li><p>options (Optional[ConsoleOptions]) \u2013 </p></li> </ul> Raises <p>errors.NoAltScreen \u2013 If the Console isn\u2019t in alt screen mode.</p> Return type <p>None</p> update_screen_lines(lines, x=0, y=0)[source]\u00b6 <p>Update lines of the screen at a given offset.</p> Parameters <ul> <li><p>lines (List[List[Segment]]) \u2013 Rendered lines (as produced by <code>render_lines()</code>).</p></li> <li><p>x (int, optional) \u2013 x offset (column no). Defaults to 0.</p></li> <li><p>y (int, optional) \u2013 y offset (column no). Defaults to 0.</p></li> </ul> Raises <p>errors.NoAltScreen \u2013 If the Console isn\u2019t in alt screen mode.</p> Return type <p>None</p> use_theme(theme, *, inherit=True)[source]\u00b6 <p>Use a different theme for the duration of the context manager.</p> Parameters <ul> <li><p>theme (Theme) \u2013 Theme instance to user.</p></li> <li><p>inherit (bool, optional) \u2013 Inherit existing console styles. Defaults to True.</p></li> </ul> Returns <p>[description]</p> Return type <p>ThemeContext</p> property width: int\u00b6 <p>Get the width of the console.</p> Returns <p>The width (in characters) of the console.</p> Return type <p>int</p> gradient ( text=\"\", colors=None, rainbow=False, invert=False, hues=3, color_sample=False, style=Style.null(), justify=None, overflow=None, end=\"\\n\", no_wrap=None, tab_size=4, spans=None)[source]\u00b6 <p>Prints gradient text to the console.</p> Parameters <p>text (str|rich.text.Text) \u2013 The text to print in gradient color.</p> <p>colors (List[Color|str|Tuple]|str) - The colors from which to generate the gradient.</p> <p>rainbow (bool) - Whether to print a full spectrum gradient or not. Defaults to False.</p> <p>invert (bool) - Whenter to invert the order of entered colors or not. Defaults to False.</p> <p>hues (Optional[int]) - The number of colors from which to generate a random gradient. Defualts to 3.</p> <p>color_sample (bool) - Whether to print blocks of color rather than letters. Defaults to False.</p> <p>style (StyleType) - The style to print the gradient in. Valid styles are \"bold\", \"italic\", or \"underline\"</p> <p>justify (JustifyMethod) - How to justify the gradient. Defualts to 'default'.</p> <p>overflow (OverflowMethod) - How to handle text that overlows the given space. Defaults to 'default'</p> <p>end (Optional[str]) - The character to end the gradient with. Defaults to \"\\n\".</p> <p>no_wrap (Optional[bool]) - Disable text wrapping, or None for default. Defaults to None.</p> <p>tab_size (int) - Number of spaces per tab, or `None` to use `console.tab_size`. Defaults to 4.</p> <p>spans (List[Span]) - A list of predefinded style spans. Defaults to None.</p> Raises <p>ColorParseError \u2013 If this Console recieves an invalid color from which to create a gradient, this error is raised.</p> Return type <p>None</p> gradient (&lt; class=\"n\"&gt; title=\"\", gradient=True, thickness=\"medium\", end=\"\\n\", align=\"center\")[source]\u00b6 <p>Prints rule to the console in gradient color. The rule may have an optional title that may be aligned to the left of the rule, the right of the rule, or the center of the rule. The horizontal rule's thickness is also variable.</p> Parameters <p>title (Union[str, rich.text.Text) \u2013 The optional title of the rule.</p> <p>gradient (bool) - Whether to print the rule to the console in gradient color or not. Defaults to True.</p> <p>thickness (Thickness) - The thickness of the rule. Valid values are:<ul> <li>\"thin\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</li> <li>\"medium\"\u00a0\u00a0\u00a0\u00a0\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501</li> <li>\"thick\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588</li> </ul> <p>end (str) - Character at end of Rule. defaults to \"\\n\".</p> <p>align (AlignMethod) - How to align the title of the rule, valid values are:     <ul> <li>\"left\"</li> <li>\"center\"</li> <li>\"right\"</li> </ul>\u00a0\u00a0\u00a0\u00a0Defaults to \"center\".</p> Raises <p>ValueError \u2013 If the gradient rule is supplied an invalid value for thickness.</p> Return type <p>None</p>"},{"location":"gradient/","title":"MaxGradient.Gradient","text":"<p>Maxgradient.gradient.Gradient is a subclass of rich.text.Text, and can be used in the same way. If a gradient is made with just a string, the gradient will automatically generate colors for you. If that's not colorful enough for you, you can pass the rainbow argument to the gradient to generate a rainbow gradient.</p> <p>If you need more control over the gradient, you can pass a list of colors to the gradient. The gradient will be evenly distributed between the colors in the list. The gradient will be applied to the text in the order it is given in the list.</p>"},{"location":"gradient/#example-1-random-gradient","title":"Example 1: Random Gradient","text":""},{"location":"gradient/#example-2-rainbow-gradient","title":"Example 2: Rainbow Gradient","text":""},{"location":"gradient/#example-3-gradient-with-specified-colors","title":"Example 3: Gradient with Specified Colors","text":""},{"location":"gradient_ref/","title":"Gradient","text":"<p>             Bases: <code>Text</code></p> <p>Text with gradient color / style.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Text</code> <p>The text to print. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>colors</code> <code>List[Optional[Color | Tuple | str | int]]</code> <p>A list of colors to use             for the gradient. Defaults to None.</p> <code>None</code> <code>rainbow</code> <code>bool</code> <p>Whether to print the gradient text in rainbow colors                across the spectrum. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>The number of colors in the gradient. Defaults to <code>3</code>.</p> <code>None</code> <code>style</code> <code>StyleType</code> <p>The style of the gradient text. Defaults to None.</p> <code>null()</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <code>justify</code> <code>Optional[JustifyMethod]</code> <p>Justify method: \"left\", \"center\",            \"full\", \"right\". Defaults to None.</p> <code>None</code> <code>overflow</code> <code>Optional[OverflowMethod]</code> <p>Overflow method: \"crop\", \"fold\",             \"ellipsis\". Defaults to None.</p> <code>None</code> <code>end</code> <code>str</code> <p>Character to end text with. Defaults to \"\\n\".</p> <code>'\\n'</code> <code>no_wrap</code> <code>bool</code> <p>Disable text wrapping, or None for default.            Defaults to None.</p> <code>None</code> <code>tab_size</code> <code>int</code> <p>Number of spaces per tab, or <code>None</code> to use            <code>console.tab_size</code>. Defaults to 8.</p> <code>4</code> <code>spans</code> <code>List[Span]</code> <p>A list of predefined style spans.            Defaults to None.</p> <code>None</code> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>class Gradient(Text):\n    \"\"\"Text with gradient color / style.\n\n    Args:\n        text (Text): The text to print. Defaults to `\"\"`.\\n\n        colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n            for the gradient. Defaults to None.\\n\n        rainbow (bool): Whether to print the gradient text in rainbow colors\\\n                across the spectrum. Defaults to False.\\n\n        hues (int): The number of colors in the gradient. Defaults to `3`.\\n\n        style (StyleType): The style of the gradient text. Defaults to None.\\n\n        verbose (bool): Whether to print verbose output. Defaults to False.\n        justify (Optional[JustifyMethod]): Justify method: \"left\", \"center\",\\\n            \"full\", \"right\". Defaults to None.\\n\n        overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\", \\\n            \"ellipsis\". Defaults to None.\\n\n        end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\\n\n        no_wrap (bool, optional): Disable text wrapping, or None for default.\\\n            Defaults to None.\\n\n        tab_size (int): Number of spaces per tab, or `None` to use\\\n            `console.tab_size`. Defaults to 8.\\n\n        spans (List[Span], optional): A list of predefined style spans.\\\n            Defaults to None.\\n\n\n    \"\"\"\n\n    __slots__ = [\n        \"_colors\",\n        \"_text\",\n        \"_length\",\n        \"length\",\n        \"_hues\",\n        \"_style\",\n        \"_spans\",\n        \"_rainbow\",\n        \"verbose\",\n    ]\n\n    def __init__(\n        self,\n        text: Optional[str | Text] = \"\",\n        colors: Optional[List[ColorType]] = None,\n        rainbow: bool = False,\n        hues: Optional[int] = None,\n        style: StyleType = Style.null(),\n        verbose: bool = False,\n        *,\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        no_wrap: Optional[bool] = None,\n        end: str = \"\\n\",\n        tab_size: Optional[int] = 4,\n        spans: Optional[List[Span]] = None,\n    ) -&gt; None:\n        \"\"\"Text styled with gradient color.\n\n        Args:\n            text (text): The text to print. Defaults to `\"\"`.\\n\n            colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n                for the gradient. Defaults to None.\\n\n            rainbow (bool): Whether to print the gradient text in rainbow colors\\\n                  across the spectrum. Defaults to False.\\n\n            hues (int): The number of colors in the gradient. Defaults to `3`.\\n\n            style (StyleType): The style of the gradient text. Defaults to None.\\n\n            verbose (bool): Whether to print verbose output. Defaults to False.\n            justify (Optional[JustifyMethod]): Justify method: \"left\", \"center\",\\\n                \"full\", \"right\". Defaults to None.\\n\n            overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\", \\\n                \"ellipsis\". Defaults to None.\\n\n            end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\\n\n            no_wrap (bool, optional): Disable text wrapping, or None for default.\\\n                Defaults to None.\\n\n            tab_size (int): Number of spaces per tab, or `None` to use\\\n                `console.tab_size`. Defaults to 4.\\n\n            spans (List[Span], optional): A list of predefined style spans.\\\n                Defaults to None.\\n\n\n        \"\"\"\n        # Parse text input\n        if isinstance(text, Text):\n            self._spans: List[Span] = text.spans\n            text = strip_control_codes(text.plain)\n        else:\n            self._spans = spans or []\n            text = strip_control_codes(str(text))\n\n        super().__init__(\n            text=text,\n            style=style,\n            justify=justify,\n            overflow=overflow,\n            no_wrap=no_wrap,\n            end=end,\n            tab_size=tab_size,\n            spans=spans,\n        )\n        self.verbose: bool = verbose or False\n        self.rainbow = rainbow\n        self._hues: int = hues or 3\n        self.colors = colors or []  # type: ignore\n        self._hues = len(self.colors)\n        gradient_substrings: Text = self.generate_gradient_substrings(True)\n        self._spans = gradient_substrings.spans\n\n    def __str__(self) -&gt; str:\n        return self.plain\n\n    def __repr__(self) -&gt; str:\n        colors = \", \".join([str(color) for color in self.colors])\n        return f\"Gradient&lt;colors=`{colors}`, text=`{self.text}`&gt;\"\n\n    def __add__(self, other: Any) -&gt; \"Text\":\n        if isinstance(other, (str, Text)):\n            result = self.copy()\n            result.append(other)\n            return result\n        return NotImplemented\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Text):\n            return NotImplemented\n        return self.plain == other.plain and self._spans == other._spans\n\n    def __contains__(self, other: object) -&gt; bool:\n        if isinstance(other, str):\n            return other in self.plain\n        elif isinstance(other, Text):\n            return other.plain in self.plain\n        return False\n\n    def __getitem__(self, slice: Union[int, slice]) -&gt; \"Text\":\n        def get_text_at(offset: int) -&gt; \"Text\":\n            _Span = Span\n            text = Text(\n                self.plain[offset],\n                spans=[\n                    _Span(0, 1, style)\n                    for start, end, style in self._spans\n                    if end &gt; offset &gt;= start\n                ],\n                end=\"\",\n            )\n            return text\n\n        if isinstance(slice, int):\n            return get_text_at(slice)\n        else:\n            start, stop, step = slice.indices(len(self.plain))\n            if step == 1:\n                lines = self.divide([start, stop])\n                return lines[1]\n            else:\n                # This would be a bit of work to implement efficiently\n                # For now, its not required\n                raise TypeError(\"slices with step!=1 are not supported\")\n\n    @property\n    def cell_len(self) -&gt; int:\n        \"\"\"Get the number of cells required to render this text.\"\"\"\n        return cell_len(self.plain)\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"The text of the gradient.\"\"\"\n\n        return self._text\n\n    @text.setter\n    def text(self, text: Optional[str | Text]) -&gt; None:\n        \"\"\"Set the text of the gradient.\"\"\"\n\n        if isinstance(text, Text):\n            sanitized_text = strip_control_codes(text.plain)\n            length = len(sanitized_text)\n            self.length: int = length\n            self._text = sanitized_text\n            self._spans = text.spans\n        elif isinstance(text, str):\n            if text == \"\":\n                raise ValueError(\"Text cannot be empty.\")\n            sanitized_text = strip_control_codes(text)\n            self._length = len(sanitized_text)\n            self._text = sanitized_text\n        elif text is None:\n            raise ValueError(\"Text cannot be None.\")\n        else:\n            raise TypeError(f\"Text must be a string or Text, not {type(text)}\")\n\n    @property\n    def hues(self) -&gt; int:\n        \"\"\"The number of colors in the gradient.\"\"\"\n        if self._hues is None:\n            return 3\n        return self._hues\n\n    @hues.setter\n    def hues(self, hues: int) -&gt; None:\n        \"\"\"Set the number of colors in the gradient.\n\n        Args:\n            hues (int): The number of colors in the gradient. Defaults to `3`.\n        \"\"\"\n\n        if hues &lt; 2:\n            raise ValueError(\"Gradient must have at least two colors.\")\n        self._hues = hues\n\n    @property\n    def style(self) -&gt; Style:\n        \"\"\"The style of the gradient.\"\"\"\n\n        return self._style\n\n    @style.setter\n    def style(self, style: Style) -&gt; None:\n        \"\"\"Set the style of the gradient.\n\n        Args:\n            style(`StyleType`): The style to set the gradient to.\n        \"\"\"\n\n        if isinstance(style, Style):\n            self._style = Style.copy(style).without_color\n        if style is None:\n            self._style = Style.null()\n        elif isinstance(style, str):\n            if style == \"\" or style == \"null\":\n                self._style = Style.null()\n            if style == \"none\" or style == \"None\":\n                self._style = Style.null()\n            self._style = Style.parse(style)\n\n    @property\n    def rainbow(self) -&gt; bool:\n        \"\"\"Whether to print the gradient text in rainbow colors across the spectrum.\"\"\"\n        rainbow: bool = self._rainbow if not None else False\n        return rainbow\n\n    @rainbow.setter\n    def rainbow(self, value: bool) -&gt; None:\n        \"\"\"Set whether to print the gradient text in rainbow colors across the spectrum.\n\n        Args:\n            value (bool): Whether to print the gradient text in rainbow colors \\\n                across the spectrum.\n        \"\"\"\n\n        if value is None:\n            self._rainbow: bool = False\n        elif isinstance(value, bool):\n            self._rainbow = value\n        elif isinstance(value, str):\n            if str(value).lower() == \"true\":\n                self._rainbow = True\n            elif str(value).lower() == \"false\":\n                self._rainbow = False\n            else:\n                raise ValueError(f\"Rainbow must be a bool, not {value}\")\n        else:\n            raise TypeError(f\"Rainbow must be a bool, not {type(value)}\")\n\n    @property\n    def colors(self) -&gt; List[Color]:\n        \"\"\"The colors of the gradient.\"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, colors: Optional[List[Color | Tuple | str]]) -&gt; None:\n        \"\"\"Set the colors of the gradient.\n\n        Args:\n            colors (List[Color|Tuple|str|int]): The colors to set the gradient to.\n        \"\"\"\n\n        if colors is None or colors == []:\n            if self._hues is None:\n                self._hues = 3\n            if self.rainbow:\n                self._hues = 10\n            _colors: List[Color] = ColorList(self._hues).color_list\n            if self.validate_colors(_colors):\n                self._colors: List[Color] = _colors\n            else:\n                raise ValueError(\"No input colors. Unable to generate colors.\")\n        elif isinstance(colors, list):\n            _colors = []\n            for color in colors:\n                if isinstance(color, (str, tuple, Color)):\n                    try:\n                        color = Color(color)\n                        _colors.append(color)\n                    except ColorParseError as cpe:\n                        raise ColorParseError(\n                            f\"Could not parse color: {color}\"\n                        ) from cpe\n                else:\n                    raise TypeError(\n                        f\"Color must be a string, tuple, or Color, not {type(color)}\"\n                    )\n            if self.validate_colors(_colors):\n                self._colors = _colors\n            else:\n                raise ValueError(\"Colors were a list of invalid colors.\")\n        else:\n            raise TypeError(f\"Colors must be a list, not {type(colors)}\")\n\n    def get_colors(\n        self,\n        input_colors: Optional[str | List[Color | Tuple | str]],\n        rainbow: bool = False,\n    ) -&gt; List[Color]:\n        \"\"\"Get the colors for the gradient.\n\n        Args:\n            colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n                for the gradient. Defaults to None.\\n\n            rainbow (bool): Whether to print the gradient text in rainbow colors \\\n                across the spectrum. Defaults to False.\\n\n            verbose (bool): Whether to print verbose output. Defaults to False.\\n\n\n        Returns:\n            List[Color]: A list of colors for the gradient.\n        \"\"\"\n        if rainbow:\n            self.hues = 10\n            color_list = ColorList(self.hues).color_list\n            assert len(color_list) == self.hues, f\"Color list length: {len(color_list)}\"\n            colors = color_list\n            if self.validate_colors(colors):\n                return colors\n            else:\n                raise ValueError(\"Rainbow Colors are invalid.\")\n        if isinstance(input_colors, str):\n            colors = self.mono(input_colors)\n            if self.validate_colors(colors):\n                return colors\n            else:\n                raise ValueError(\"Colors are invalid. Input colors is a string.\")\n        if input_colors is not None:\n            colors = []\n            for color in input_colors:\n                try:\n                    color = Color(color)\n                    colors.append(color)\n                except ColorParseError as error:\n                    raise ColorParseError(f\"Can't parse color: {color}\") from error\n            if self.validate_colors(colors):\n                return colors\n            else:\n                raise ValueError(\"Colors are invalid. Input colors are not None.\")\n        elif input_colors is []:\n            color_list = ColorList(self.hues or 3).color_list\n            colors = color_list[: self.hues]\n            if self.validate_colors(colors):\n                return colors\n            else:\n                raise ValueError(\"Colors are invalid. Input colors: []\")\n        else:\n            color_list = ColorList(self.hues).color_list\n            colors = color_list[: self.hues]\n            if self.validate_colors(colors):\n                return colors\n            else:\n                raise ValueError(\"Colors are invalid.\")\n\n    def mono(self, color: str | Color) -&gt; List[Color]:\n        \"\"\"Create a list of monochromatic hues from a color.\n\n        Args:\n            color (str|Color): The color to generate monochromatic hues from.\n        \"\"\"\n\n        if isinstance(color, str):\n            try:\n                color = Color(color)\n            except ColorParseError as cpe:\n                raise ColorParseError(f\"Could not parse color: {color}\") from cpe\n        if not isinstance(color, Color):\n            raise TypeError(f\"Color must be a string or Color, not {type(color)}\")\n        else:\n            return [\n                Color(color.darken(0.6)),\n                Color(color.darken(0.3)),\n                color,\n                Color(color.lighten(0.3)),\n                Color(color.lighten(0.6)),\n            ]\n\n    def validate_colors(self, colors: Optional[List[Color]]) -&gt; bool:\n        \"\"\"Validate self.colors to ensure that it is a list of colors.\"\"\"\n        valid: bool = True\n        if colors is None:\n            return False\n        elif colors == []:\n            return False\n        for color in colors:\n            if not isinstance(color, Color):\n                return False\n        if valid:\n            return True\n        return False\n\n    def generate_gradient_substrings(self, verbose: bool = False) -&gt; Text:\n        \"\"\"Generate gradient spans.\n\n        Returns:\n            List[Span]: The gradient spans.\n        \"\"\"\n        text = self.generate_text()\n        gradient_string = Text()\n        indexes: List[List[int]] = self.generate_indexes()\n        substrings: List[str] = self.generate_substrings(indexes, text)\n\n        if verbose:\n            substrings_table = Table(\n                \"Index\", \"Substring\", \"Length\", expand=False, highlight=True\n            )\n\n        for index, substring in enumerate(substrings):\n            gradient_length = len(substring)\n            subtext = Text(substring)\n            if verbose:\n                substrings_table.add_row(  # type: ignore\n                    str(index),\n                    subtext,\n                    str(gradient_length),\n                )\n\n            if index &lt; self.hues - 1:\n                color1 = self.colors[index]\n                r1, g1, b1 = color1.triplet\n                color2 = self.colors[index + 1]\n                r2, g2, b2 = color2.triplet\n                dr = r2 - r1\n                dg = g2 - g1\n                db = b2 - b1\n\n            for subindex in range(gradient_length):\n                blend = subindex / gradient_length\n                red = int(r1 + (blend * dr))  # type: ignore\n                green = int(g1 + (blend * dg))  # type: ignore\n                blue = int(b1 + (blend * db))  # type: ignore\n                color = f\"#{red:02X}{green:02X}{blue:02X}\"\n                subtext.stylize(color, subindex, subindex + 1)\n\n            if verbose:\n                gradient_string = Text.assemble(\n                    gradient_string,\n                    subtext,\n                    style=self.style,\n                    justify=self.justify,\n                    overflow=self.overflow,\n                    no_wrap=self.no_wrap,\n                    end=self.end,\n                    tab_size=self.tab_size or 4,\n                )\n                substrings_table.add_row(  # type: ignore\n                    f\"{index}\", subtext, f\"{len(gradient_string)}\"\n                )\n        return gradient_string\n\n    def clean_spans(self, gradient_string: Text) -&gt; List[Span]:\n        \"\"\"Clean up redundant spans\"\"\"\n        spans: List[Span] = []\n        for span in gradient_string.spans:\n            start = span.start\n            end = span.end\n            style = span.style\n            if start + 1 == end:\n                spans.append(Span(start, end, style))\n            if style == Style():\n                continue\n            if style == \"\":\n                continue\n            spans.append(Span(start, end, style))\n        return spans\n\n    def generate_text(self) -&gt; str:\n        \"\"\"Get the gradient text.\n\n        Returns:\n            str: The gradient text.\n        \"\"\"\n        if isinstance(self._text, str):\n            return self._text\n        if self._text:\n            return \"\".join(self._text)\n        else:\n            raise TypeError(\"Gradient hasn't yet set a text value.\")\n\n    def generate_indexes(self, verbose: bool = False) -&gt; List[List[int]]:\n        \"\"\"Generate the indexes for the gradient substring.\n\n        Returns:\n            List[List[int]]: The indexes for the gradient substring.\n        \"\"\"\n        if self.hues &lt; 2:\n            self.hues = 3\n        result = np.array_split(np.arange(self._length), self.hues - 1)  # noqa: F722\n        indexes: List[List[int]] = [sublist.tolist() for sublist in result]\n        for count, index in enumerate(indexes):\n            if verbose:\n                console.log(\n                    f\"[b white]Index {count}:[/]{', '.join([str(i) for i in index])}\"\n                )\n        return indexes\n\n    def generate_substrings(self, indexes: List[List[int]], text: str) -&gt; List[str]:\n        \"\"\"Generate a list of substrings for the gradient.\n\n        Args:\n            indexes (List[List[int]]): The indexes for the gradient substring.\n            text (str): The text to generate the gradient substring from.\n            verbose (bool, optional): Whether to print verbose output.\n                Defaults to VERBOSE.\n        \"\"\"\n        substrings: List[str] = []\n        for index in indexes:\n            substring = self.generate_substring(index, text)\n            substrings.append(substring)\n        return substrings\n\n    def generate_substring(self, index: List[int], text: str) -&gt; str:\n        \"\"\"Generate a string to make a GradientSubstring.\n\n        Args:\n            index (List[int]): The index of the substring.\n            text (str): The text to generate the gradient substring from.\n            verbose (bool, optional): Whether to print verbose output.\n                Defaults to VERBOSE.\n\n        Returns:\n            str: The substring.\n        \"\"\"\n        substring_list: List[str] = []\n        for num in index:\n            substring_list.append(text[num])\n        substring = \"\".join(substring_list)\n        return substring\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -&gt; Iterable[Segment]:\n        tab_size: int = console.tab_size or self.tab_size or 8\n        justify = self.justify or options.justify or DEFAULT_JUSTIFY\n\n        overflow = self.overflow or options.overflow or DEFAULT_OVERFLOW\n\n        lines = self.wrap(\n            console,\n            options.max_width,\n            justify=justify,\n            overflow=overflow,\n            tab_size=tab_size or 8,\n            no_wrap=pick_bool(self.no_wrap, options.no_wrap, False),  # type: ignore\n        )\n        all_lines = Text(\"\\n\").join(lines)\n        yield from all_lines.render(console, end=self.end)\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -&gt; Measurement:\n        text = self.plain\n        lines = text.splitlines()\n        max_text_width = max(cell_len(line) for line in lines) if lines else 0\n        words = text.split()\n        min_text_width = (\n            max(cell_len(word) for word in words) if words else max_text_width\n        )\n        return Measurement(min_text_width, max_text_width)\n\n    def render(self, console: \"Console\", end: str = \"\") -&gt; Iterable[\"Segment\"]:\n        \"\"\"Render the text as Segments.\n\n        Args:\n            console (Console): Console instance.\n            end (Optional[str], optional): Optional end character.\n\n        Returns:\n            Iterable[Segment]: Result of render that may be written to the console.\n        \"\"\"\n        _Segment = Segment\n        text = str.strip(self.plain)\n        if not self._spans:\n            yield Segment(text)\n            if end:\n                yield _Segment(end)\n            return\n        get_style = partial(console.get_style, default=Style.null())\n\n        enumerated_spans = list(enumerate(self._spans, 1))\n        style_map = {index: get_style(span.style) for index, span in enumerated_spans}\n        style_map[0] = get_style(self.style)\n\n        spans = [\n            (0, False, 0),\n            *((span.start, False, index) for index, span in enumerated_spans),\n            *((span.end, True, index) for index, span in enumerated_spans),\n            (len(text), True, 0),\n        ]\n        spans.sort(key=itemgetter(0, 1))\n\n        stack: List[int] = []\n        stack_append = stack.append\n        stack_pop = stack.remove\n\n        style_cache: Dict[Tuple[Style, ...], Style] = {}\n        style_cache_get = style_cache.get\n        combine = Style.combine\n\n        def get_current_style() -&gt; Style:\n            \"\"\"Construct current style from stack.\"\"\"\n            styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n            cached_style = style_cache_get(styles)\n            if cached_style is not None:\n                return cached_style\n            current_style = combine(styles)\n            style_cache[styles] = current_style\n            return current_style\n\n        for (offset, leaving, style_id), (next_offset, _, _) in zip(spans, spans[1:]):\n            if leaving:\n                stack_pop(style_id)\n            else:\n                stack_append(style_id)\n            if next_offset &gt; offset:\n                yield _Segment(text[offset:next_offset], get_current_style())\n        if end:\n            yield _Segment(end)\n\n    def as_text(self) -&gt; Text:\n        \"\"\"Return the gradient as a Text object.\"\"\"\n        return Text(\n            self.text,\n            style=self.style,\n            justify=self.justify,\n            overflow=self.overflow,\n            no_wrap=self.no_wrap,\n            end=self.end,\n            tab_size=self.tab_size,\n            spans=self.spans,\n        )\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.cell_len","title":"<code>cell_len: int</code>  <code>property</code>","text":"<p>Get the number of cells required to render this text.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.colors","title":"<code>colors: List[Color]</code>  <code>property</code> <code>writable</code>","text":"<p>The colors of the gradient.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.hues","title":"<code>hues: int</code>  <code>property</code> <code>writable</code>","text":"<p>The number of colors in the gradient.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.rainbow","title":"<code>rainbow: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether to print the gradient text in rainbow colors across the spectrum.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.style","title":"<code>style: Style</code>  <code>property</code> <code>writable</code>","text":"<p>The style of the gradient.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.text","title":"<code>text: str</code>  <code>property</code> <code>writable</code>","text":"<p>The text of the gradient.</p>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.__init__","title":"<code>__init__(text='', colors=None, rainbow=False, hues=None, style=Style.null(), verbose=False, *, justify=None, overflow=None, no_wrap=None, end='\\n', tab_size=4, spans=None)</code>","text":"<p>Text styled with gradient color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>text</code> <p>The text to print. Defaults to <code>\"\"</code>.</p> <code>''</code> <code>colors</code> <code>List[Optional[Color | Tuple | str | int]]</code> <p>A list of colors to use                 for the gradient. Defaults to None.</p> <code>None</code> <code>rainbow</code> <code>bool</code> <p>Whether to print the gradient text in rainbow colors                  across the spectrum. Defaults to False.</p> <code>False</code> <code>hues</code> <code>int</code> <p>The number of colors in the gradient. Defaults to <code>3</code>.</p> <code>None</code> <code>style</code> <code>StyleType</code> <p>The style of the gradient text. Defaults to None.</p> <code>null()</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <code>justify</code> <code>Optional[JustifyMethod]</code> <p>Justify method: \"left\", \"center\",                \"full\", \"right\". Defaults to None.</p> <code>None</code> <code>overflow</code> <code>Optional[OverflowMethod]</code> <p>Overflow method: \"crop\", \"fold\",                 \"ellipsis\". Defaults to None.</p> <code>None</code> <code>end</code> <code>str</code> <p>Character to end text with. Defaults to \"\\n\".</p> <code>'\\n'</code> <code>no_wrap</code> <code>bool</code> <p>Disable text wrapping, or None for default.                Defaults to None.</p> <code>None</code> <code>tab_size</code> <code>int</code> <p>Number of spaces per tab, or <code>None</code> to use                <code>console.tab_size</code>. Defaults to 4.</p> <code>4</code> <code>spans</code> <code>List[Span]</code> <p>A list of predefined style spans.                Defaults to None.</p> <code>None</code> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def __init__(\n    self,\n    text: Optional[str | Text] = \"\",\n    colors: Optional[List[ColorType]] = None,\n    rainbow: bool = False,\n    hues: Optional[int] = None,\n    style: StyleType = Style.null(),\n    verbose: bool = False,\n    *,\n    justify: Optional[JustifyMethod] = None,\n    overflow: Optional[OverflowMethod] = None,\n    no_wrap: Optional[bool] = None,\n    end: str = \"\\n\",\n    tab_size: Optional[int] = 4,\n    spans: Optional[List[Span]] = None,\n) -&gt; None:\n    \"\"\"Text styled with gradient color.\n\n    Args:\n        text (text): The text to print. Defaults to `\"\"`.\\n\n        colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n            for the gradient. Defaults to None.\\n\n        rainbow (bool): Whether to print the gradient text in rainbow colors\\\n              across the spectrum. Defaults to False.\\n\n        hues (int): The number of colors in the gradient. Defaults to `3`.\\n\n        style (StyleType): The style of the gradient text. Defaults to None.\\n\n        verbose (bool): Whether to print verbose output. Defaults to False.\n        justify (Optional[JustifyMethod]): Justify method: \"left\", \"center\",\\\n            \"full\", \"right\". Defaults to None.\\n\n        overflow (Optional[OverflowMethod]):  Overflow method: \"crop\", \"fold\", \\\n            \"ellipsis\". Defaults to None.\\n\n        end (str, optional): Character to end text with. Defaults to \"\\\\\\\\n\".\\n\n        no_wrap (bool, optional): Disable text wrapping, or None for default.\\\n            Defaults to None.\\n\n        tab_size (int): Number of spaces per tab, or `None` to use\\\n            `console.tab_size`. Defaults to 4.\\n\n        spans (List[Span], optional): A list of predefined style spans.\\\n            Defaults to None.\\n\n\n    \"\"\"\n    # Parse text input\n    if isinstance(text, Text):\n        self._spans: List[Span] = text.spans\n        text = strip_control_codes(text.plain)\n    else:\n        self._spans = spans or []\n        text = strip_control_codes(str(text))\n\n    super().__init__(\n        text=text,\n        style=style,\n        justify=justify,\n        overflow=overflow,\n        no_wrap=no_wrap,\n        end=end,\n        tab_size=tab_size,\n        spans=spans,\n    )\n    self.verbose: bool = verbose or False\n    self.rainbow = rainbow\n    self._hues: int = hues or 3\n    self.colors = colors or []  # type: ignore\n    self._hues = len(self.colors)\n    gradient_substrings: Text = self.generate_gradient_substrings(True)\n    self._spans = gradient_substrings.spans\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.as_text","title":"<code>as_text()</code>","text":"<p>Return the gradient as a Text object.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def as_text(self) -&gt; Text:\n    \"\"\"Return the gradient as a Text object.\"\"\"\n    return Text(\n        self.text,\n        style=self.style,\n        justify=self.justify,\n        overflow=self.overflow,\n        no_wrap=self.no_wrap,\n        end=self.end,\n        tab_size=self.tab_size,\n        spans=self.spans,\n    )\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.clean_spans","title":"<code>clean_spans(gradient_string)</code>","text":"<p>Clean up redundant spans</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def clean_spans(self, gradient_string: Text) -&gt; List[Span]:\n    \"\"\"Clean up redundant spans\"\"\"\n    spans: List[Span] = []\n    for span in gradient_string.spans:\n        start = span.start\n        end = span.end\n        style = span.style\n        if start + 1 == end:\n            spans.append(Span(start, end, style))\n        if style == Style():\n            continue\n        if style == \"\":\n            continue\n        spans.append(Span(start, end, style))\n    return spans\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.generate_gradient_substrings","title":"<code>generate_gradient_substrings(verbose=False)</code>","text":"<p>Generate gradient spans.</p> <p>Returns:</p> Type Description <code>Text</code> <p>List[Span]: The gradient spans.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def generate_gradient_substrings(self, verbose: bool = False) -&gt; Text:\n    \"\"\"Generate gradient spans.\n\n    Returns:\n        List[Span]: The gradient spans.\n    \"\"\"\n    text = self.generate_text()\n    gradient_string = Text()\n    indexes: List[List[int]] = self.generate_indexes()\n    substrings: List[str] = self.generate_substrings(indexes, text)\n\n    if verbose:\n        substrings_table = Table(\n            \"Index\", \"Substring\", \"Length\", expand=False, highlight=True\n        )\n\n    for index, substring in enumerate(substrings):\n        gradient_length = len(substring)\n        subtext = Text(substring)\n        if verbose:\n            substrings_table.add_row(  # type: ignore\n                str(index),\n                subtext,\n                str(gradient_length),\n            )\n\n        if index &lt; self.hues - 1:\n            color1 = self.colors[index]\n            r1, g1, b1 = color1.triplet\n            color2 = self.colors[index + 1]\n            r2, g2, b2 = color2.triplet\n            dr = r2 - r1\n            dg = g2 - g1\n            db = b2 - b1\n\n        for subindex in range(gradient_length):\n            blend = subindex / gradient_length\n            red = int(r1 + (blend * dr))  # type: ignore\n            green = int(g1 + (blend * dg))  # type: ignore\n            blue = int(b1 + (blend * db))  # type: ignore\n            color = f\"#{red:02X}{green:02X}{blue:02X}\"\n            subtext.stylize(color, subindex, subindex + 1)\n\n        if verbose:\n            gradient_string = Text.assemble(\n                gradient_string,\n                subtext,\n                style=self.style,\n                justify=self.justify,\n                overflow=self.overflow,\n                no_wrap=self.no_wrap,\n                end=self.end,\n                tab_size=self.tab_size or 4,\n            )\n            substrings_table.add_row(  # type: ignore\n                f\"{index}\", subtext, f\"{len(gradient_string)}\"\n            )\n    return gradient_string\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.generate_indexes","title":"<code>generate_indexes(verbose=False)</code>","text":"<p>Generate the indexes for the gradient substring.</p> <p>Returns:</p> Type Description <code>List[List[int]]</code> <p>List[List[int]]: The indexes for the gradient substring.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def generate_indexes(self, verbose: bool = False) -&gt; List[List[int]]:\n    \"\"\"Generate the indexes for the gradient substring.\n\n    Returns:\n        List[List[int]]: The indexes for the gradient substring.\n    \"\"\"\n    if self.hues &lt; 2:\n        self.hues = 3\n    result = np.array_split(np.arange(self._length), self.hues - 1)  # noqa: F722\n    indexes: List[List[int]] = [sublist.tolist() for sublist in result]\n    for count, index in enumerate(indexes):\n        if verbose:\n            console.log(\n                f\"[b white]Index {count}:[/]{', '.join([str(i) for i in index])}\"\n            )\n    return indexes\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.generate_substring","title":"<code>generate_substring(index, text)</code>","text":"<p>Generate a string to make a GradientSubstring.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>List[int]</code> <p>The index of the substring.</p> required <code>text</code> <code>str</code> <p>The text to generate the gradient substring from.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to VERBOSE.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The substring.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def generate_substring(self, index: List[int], text: str) -&gt; str:\n    \"\"\"Generate a string to make a GradientSubstring.\n\n    Args:\n        index (List[int]): The index of the substring.\n        text (str): The text to generate the gradient substring from.\n        verbose (bool, optional): Whether to print verbose output.\n            Defaults to VERBOSE.\n\n    Returns:\n        str: The substring.\n    \"\"\"\n    substring_list: List[str] = []\n    for num in index:\n        substring_list.append(text[num])\n    substring = \"\".join(substring_list)\n    return substring\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.generate_substrings","title":"<code>generate_substrings(indexes, text)</code>","text":"<p>Generate a list of substrings for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>indexes</code> <code>List[List[int]]</code> <p>The indexes for the gradient substring.</p> required <code>text</code> <code>str</code> <p>The text to generate the gradient substring from.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to VERBOSE.</p> required Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def generate_substrings(self, indexes: List[List[int]], text: str) -&gt; List[str]:\n    \"\"\"Generate a list of substrings for the gradient.\n\n    Args:\n        indexes (List[List[int]]): The indexes for the gradient substring.\n        text (str): The text to generate the gradient substring from.\n        verbose (bool, optional): Whether to print verbose output.\n            Defaults to VERBOSE.\n    \"\"\"\n    substrings: List[str] = []\n    for index in indexes:\n        substring = self.generate_substring(index, text)\n        substrings.append(substring)\n    return substrings\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.generate_text","title":"<code>generate_text()</code>","text":"<p>Get the gradient text.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The gradient text.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def generate_text(self) -&gt; str:\n    \"\"\"Get the gradient text.\n\n    Returns:\n        str: The gradient text.\n    \"\"\"\n    if isinstance(self._text, str):\n        return self._text\n    if self._text:\n        return \"\".join(self._text)\n    else:\n        raise TypeError(\"Gradient hasn't yet set a text value.\")\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.get_colors","title":"<code>get_colors(input_colors, rainbow=False)</code>","text":"<p>Get the colors for the gradient.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>List[Optional[Color | Tuple | str | int]]</code> <p>A list of colors to use                 for the gradient. Defaults to None.</p> required <code>rainbow</code> <code>bool</code> <p>Whether to print the gradient text in rainbow colors                 across the spectrum. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> required <p>Returns:</p> Type Description <code>List[Color]</code> <p>List[Color]: A list of colors for the gradient.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def get_colors(\n    self,\n    input_colors: Optional[str | List[Color | Tuple | str]],\n    rainbow: bool = False,\n) -&gt; List[Color]:\n    \"\"\"Get the colors for the gradient.\n\n    Args:\n        colors (List[Optional[Color|Tuple|str|int]]): A list of colors to use \\\n            for the gradient. Defaults to None.\\n\n        rainbow (bool): Whether to print the gradient text in rainbow colors \\\n            across the spectrum. Defaults to False.\\n\n        verbose (bool): Whether to print verbose output. Defaults to False.\\n\n\n    Returns:\n        List[Color]: A list of colors for the gradient.\n    \"\"\"\n    if rainbow:\n        self.hues = 10\n        color_list = ColorList(self.hues).color_list\n        assert len(color_list) == self.hues, f\"Color list length: {len(color_list)}\"\n        colors = color_list\n        if self.validate_colors(colors):\n            return colors\n        else:\n            raise ValueError(\"Rainbow Colors are invalid.\")\n    if isinstance(input_colors, str):\n        colors = self.mono(input_colors)\n        if self.validate_colors(colors):\n            return colors\n        else:\n            raise ValueError(\"Colors are invalid. Input colors is a string.\")\n    if input_colors is not None:\n        colors = []\n        for color in input_colors:\n            try:\n                color = Color(color)\n                colors.append(color)\n            except ColorParseError as error:\n                raise ColorParseError(f\"Can't parse color: {color}\") from error\n        if self.validate_colors(colors):\n            return colors\n        else:\n            raise ValueError(\"Colors are invalid. Input colors are not None.\")\n    elif input_colors is []:\n        color_list = ColorList(self.hues or 3).color_list\n        colors = color_list[: self.hues]\n        if self.validate_colors(colors):\n            return colors\n        else:\n            raise ValueError(\"Colors are invalid. Input colors: []\")\n    else:\n        color_list = ColorList(self.hues).color_list\n        colors = color_list[: self.hues]\n        if self.validate_colors(colors):\n            return colors\n        else:\n            raise ValueError(\"Colors are invalid.\")\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.mono","title":"<code>mono(color)</code>","text":"<p>Create a list of monochromatic hues from a color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str | Color</code> <p>The color to generate monochromatic hues from.</p> required Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def mono(self, color: str | Color) -&gt; List[Color]:\n    \"\"\"Create a list of monochromatic hues from a color.\n\n    Args:\n        color (str|Color): The color to generate monochromatic hues from.\n    \"\"\"\n\n    if isinstance(color, str):\n        try:\n            color = Color(color)\n        except ColorParseError as cpe:\n            raise ColorParseError(f\"Could not parse color: {color}\") from cpe\n    if not isinstance(color, Color):\n        raise TypeError(f\"Color must be a string or Color, not {type(color)}\")\n    else:\n        return [\n            Color(color.darken(0.6)),\n            Color(color.darken(0.3)),\n            color,\n            Color(color.lighten(0.3)),\n            Color(color.lighten(0.6)),\n        ]\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.render","title":"<code>render(console, end='')</code>","text":"<p>Render the text as Segments.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>Console instance.</p> required <code>end</code> <code>Optional[str]</code> <p>Optional end character.</p> <code>''</code> <p>Returns:</p> Type Description <code>Iterable[Segment]</code> <p>Iterable[Segment]: Result of render that may be written to the console.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def render(self, console: \"Console\", end: str = \"\") -&gt; Iterable[\"Segment\"]:\n    \"\"\"Render the text as Segments.\n\n    Args:\n        console (Console): Console instance.\n        end (Optional[str], optional): Optional end character.\n\n    Returns:\n        Iterable[Segment]: Result of render that may be written to the console.\n    \"\"\"\n    _Segment = Segment\n    text = str.strip(self.plain)\n    if not self._spans:\n        yield Segment(text)\n        if end:\n            yield _Segment(end)\n        return\n    get_style = partial(console.get_style, default=Style.null())\n\n    enumerated_spans = list(enumerate(self._spans, 1))\n    style_map = {index: get_style(span.style) for index, span in enumerated_spans}\n    style_map[0] = get_style(self.style)\n\n    spans = [\n        (0, False, 0),\n        *((span.start, False, index) for index, span in enumerated_spans),\n        *((span.end, True, index) for index, span in enumerated_spans),\n        (len(text), True, 0),\n    ]\n    spans.sort(key=itemgetter(0, 1))\n\n    stack: List[int] = []\n    stack_append = stack.append\n    stack_pop = stack.remove\n\n    style_cache: Dict[Tuple[Style, ...], Style] = {}\n    style_cache_get = style_cache.get\n    combine = Style.combine\n\n    def get_current_style() -&gt; Style:\n        \"\"\"Construct current style from stack.\"\"\"\n        styles = tuple(style_map[_style_id] for _style_id in sorted(stack))\n        cached_style = style_cache_get(styles)\n        if cached_style is not None:\n            return cached_style\n        current_style = combine(styles)\n        style_cache[styles] = current_style\n        return current_style\n\n    for (offset, leaving, style_id), (next_offset, _, _) in zip(spans, spans[1:]):\n        if leaving:\n            stack_pop(style_id)\n        else:\n            stack_append(style_id)\n        if next_offset &gt; offset:\n            yield _Segment(text[offset:next_offset], get_current_style())\n    if end:\n        yield _Segment(end)\n</code></pre>"},{"location":"gradient_ref/#maxgradient.gradient.Gradient.validate_colors","title":"<code>validate_colors(colors)</code>","text":"<p>Validate self.colors to ensure that it is a list of colors.</p> Source code in <code>src/maxgradient/gradient.py</code> <pre><code>def validate_colors(self, colors: Optional[List[Color]]) -&gt; bool:\n    \"\"\"Validate self.colors to ensure that it is a list of colors.\"\"\"\n    valid: bool = True\n    if colors is None:\n        return False\n    elif colors == []:\n        return False\n    for color in colors:\n        if not isinstance(color, Color):\n            return False\n    if valid:\n        return True\n    return False\n</code></pre>"},{"location":"possible_colors/","title":"Possible Colors","text":""},{"location":"possible_colors/#gradient-colors","title":"Gradient Colors","text":""},{"location":"possible_colors/#rich-standard-colors","title":"Rich Standard Colors","text":"<p>MaxGradient supports all of the Rich Standard Colors:</p> <p></p> Rich Color Accepted Formats <p>Can parse rich colors in multiple formats:</p> <ul> <li>Name: Case insensitive.</li> <li>HEX: Case insensitive.</li> <li>RGB: With or without the <code>rgb</code> prefix.</li> <li>RGB: With or without spaces between the numbers.</li> </ul> Type Example 1 Example 2 Example 3 Name grey93  (case insensitive) Salmon1 Spring-green1 Hex #eeeeee  (case insensitive) #FF875F #00ff87 RGB (238,238,238) (without 'rgb') rgb(255,135,95) (with 'rgb') rgb(0, 255, 135)  (with spaces)"},{"location":"possible_colors/#x11-colors","title":"X11 Colors","text":"<p>MaxGradient also supports all of the X11 color names as well as the their hex color codes, RGB color codes, as well as RGB color tuples.</p> <p></p>"}]}